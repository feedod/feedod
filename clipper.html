<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover"
    />
    <meta name="color-scheme" content="dark" />
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4.1.18"></script>
    <style type="text/tailwindcss">
      @theme {
        --color-bg: #0b0b0f;
        --color-surface: #1c1c1e;
        --color-border: #2c2c2e;
        --color-text: #ffffff;
        --color-muted: #8e8e93;
      }

      * {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
      }

      html,
      body {
        background: var(--color-bg);
        font-family:
          -apple-system, BlinkMacSystemFont, "SF Pro Text", system-ui,
          sans-serif;
        overscroll-behavior: none;
        -webkit-font-smoothing: antialiased;
        scrollbar-width: none;
      }

      html::-webkit-scrollbar,
      body::-webkit-scrollbar {
        display: none;
      }

      body {
        padding: env(safe-area-inset-top) env(safe-area-inset-right)
          env(safe-area-inset-bottom) env(safe-area-inset-left);
      }

      input {
        font-size: 16px;
        caret-color: #ffffff;
      }

      input:focus {
        outline: none;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes shimmer {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }

      .fade {
        animation: fadeIn 0.4s cubic-bezier(0.25, 1, 0.5, 1) both;
      }

      .skeleton {
        background: linear-gradient(
          90deg,
          var(--color-surface) 25%,
          var(--color-border) 50%,
          var(--color-surface) 75%
        );
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
      }
    </style>
  </head>
  <body
    x-data="ClipperApp"
    @beforeunload.window="destroy()"
    class="flex min-h-dvh flex-col select-none bg-bg text-text"
  >
    <main
      class="mx-auto flex w-full max-w-md flex-1 flex-col overflow-y-auto px-5 pb-32"
    >
      <header class="fade pb-8 pt-10 text-center">
        <h1 class="text-3xl font-bold tracking-tight">Clipper</h1>
        <p class="mt-2 text-sm text-muted" x-text="statusText"></p>
      </header>

      <section class="fade space-y-3" style="animation-delay: 50ms">
        <div class="relative">
          <div
            class="pointer-events-none absolute left-4 top-1/2 -translate-y-1/2"
          >
            <svg
              class="h-5 w-5 text-muted"
              fill="none"
              stroke="currentColor"
              stroke-width="1.5"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244"
              />
            </svg>
          </div>
          <input
            type="url"
            x-ref="input"
            x-model="url"
            @input.debounce.300ms="detect()"
            @paste="$nextTick(() => detect())"
            @keydown.enter.prevent="download"
            :disabled="isLoading"
            placeholder="Вставьте ссылку на видео"
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            class="h-14 w-full rounded-2xl border border-border bg-surface pl-12 pr-14 text-text transition-colors placeholder:text-muted focus:border-text/20 disabled:opacity-40"
          />
          <div
            class="absolute right-4 top-1/2 flex -translate-y-1/2 items-center gap-2"
          >
            <button
              x-show="url.length > 0"
              x-transition:enter="transition duration-100 ease-out"
              x-transition:enter-start="scale-90 opacity-0"
              x-transition:enter-end="scale-100 opacity-100"
              x-transition:leave="transition duration-75 ease-in"
              x-transition:leave-start="scale-100 opacity-100"
              x-transition:leave-end="scale-90 opacity-0"
              @click="clear"
              :disabled="isLoading"
              class="grid h-8 w-8 place-items-center rounded-full bg-border transition-all duration-75 ease-out active:scale-[0.97] active:opacity-80 disabled:opacity-40"
              type="button"
            >
              <svg
                class="h-4 w-4 text-muted"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M6 18L18 6M6 6l12 12"
                />
              </svg>
            </button>
          </div>
        </div>

        <button
          x-show="platform && !isLoading && !video"
          x-transition.opacity.duration.150ms
          @click="download"
          :disabled="isLoading"
          :style="{ backgroundColor: platform?.colors?.primary }"
          class="flex h-14 w-full items-center justify-center gap-2.5 rounded-2xl font-semibold text-white transition-all duration-75 ease-out active:scale-[0.97] active:opacity-80 disabled:opacity-40"
          type="button"
        >
          <svg
            class="h-5 w-5"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"
            />
          </svg>
          <span>Сохранить видео</span>
        </button>
      </section>

      <template x-if="isLoading">
        <section
          class="fade flex flex-1 flex-col items-center justify-center py-20"
        >
          <div class="mb-6 w-full max-w-60">
            <div class="mb-3 flex items-center justify-between">
              <span class="text-sm font-semibold text-text">Загрузка</span>
              <span
                class="text-sm font-semibold text-text"
                x-text="progress + '%'"
              ></span>
            </div>
            <div
              class="h-2 overflow-hidden rounded-full border border-border bg-surface"
            >
              <div
                class="h-full rounded-full transition-all duration-200 ease-out"
                :style="{ backgroundColor: platform?.colors?.progress, width: progress + '%' }"
              ></div>
            </div>
          </div>
          <p class="text-sm text-muted" x-text="loadingText"></p>
        </section>
      </template>

      <template x-if="error && !isLoading">
        <section
          x-ref="errorSection"
          x-effect="if (error && !isLoading) scrollToError()"
          class="fade mt-6 rounded-2xl border border-red-900/40 bg-red-950/60 p-4"
        >
          <div class="flex items-start gap-3">
            <div
              class="grid h-10 w-10 shrink-0 place-items-center rounded-full bg-red-100"
            >
              <svg
                class="h-5 w-5 text-red-500"
                fill="none"
                stroke="currentColor"
                stroke-width="1.5"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0zm-9 3.75h.008v.008H12v-.008z"
                />
              </svg>
            </div>
            <div class="min-w-0 flex-1 pt-0.5">
              <p class="text-sm font-semibold text-gray-600">Ошибка</p>
              <p class="mt-0.5 text-sm text-gray-500" x-text="error"></p>
            </div>
          </div>
        </section>
      </template>

      <template x-if="video && !isLoading">
        <section class="fade mt-6 space-y-4">
          <div
            class="overflow-hidden rounded-2xl border border-border bg-surface"
          >
            <div class="relative h-[56dvh] w-full bg-black">
              <video
                x-ref="videoPlayer"
                :src="currentVideoUrl"
                :poster="video.cover"
                :key="selectedQuality"
                @loadeddata="$el.currentTime = 0"
                class="absolute inset-0 h-full w-full object-contain"
                controls
                playsinline
                webkit-playsinline
              ></video>
              <div
                class="absolute left-3 top-3 flex items-center gap-1.5 rounded-lg bg-black/70 backdrop-blur px-2.5 py-1.5 shadow-sm"
              >
                <svg
                  class="h-4 w-4"
                  :style="{ color: platform?.colors?.icon }"
                  viewBox="0 0 24 24"
                  fill="currentColor"
                >
                  <path :d="platform?.icon" />
                </svg>
                <span
                  class="text-xs font-semibold text-text"
                  x-text="platform?.name"
                ></span>
              </div>
              <div
                class="absolute right-3 top-3 flex items-center justify-center rounded-lg bg-black/70 backdrop-blur px-2.5 py-1.5 shadow-sm"
              >
                <span
                  class="text-xs font-semibold leading-none text-text"
                  x-text="NumberFormatter.formatDuration(video.duration)"
                ></span>
              </div>
              <div
                class="absolute bottom-3 right-3 flex items-center justify-center rounded-lg bg-black/70 backdrop-blur px-2.5 py-1.5 shadow-sm"
              >
                <span
                  class="text-xs font-semibold leading-none text-text"
                  x-text="currentQualityLabel"
                ></span>
              </div>
            </div>
          </div>

          <div
            x-show="hasMultipleQualities && !isChangingQuality"
            x-transition
            class="flex gap-2"
          >
            <template x-for="q in availableQualities" :key="q.key">
              <button
                @click="selectQuality(q.key)"
                :disabled="isChangingQuality"
                :class="selectedQuality === q.key ? 'border-border bg-white text-black' : 'border-border bg-surface text-text'"
                class="flex-1 rounded-xl border py-2.5 text-sm font-semibold transition-all duration-75 ease-out active:scale-[0.97] disabled:opacity-50"
                x-text="q.label"
              ></button>
            </template>
          </div>

          <div
            x-show="isChangingQuality"
            class="flex items-center justify-center gap-2 py-2.5"
          >
            <svg
              class="h-4 w-4 animate-spin text-muted"
              fill="none"
              viewBox="0 0 24 24"
            >
              <circle
                class="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                stroke-width="4"
              ></circle>
              <path
                class="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              ></path>
            </svg>
            <span class="text-sm text-muted">Смена качества...</span>
          </div>

          <button
            @click="openAuthorProfile"
            class="flex w-full items-center gap-3 rounded-2xl border border-border bg-surface p-4 text-left transition-all duration-75 ease-out active:scale-[0.97] active:opacity-80"
          >
            <img
              :src="video.author?.avatar"
              :alt="video.author?.nickname"
              @error="if ($event.target.src !== AppAssets.avatar) $event.target.src = AppAssets.avatar"
              class="h-12 w-12 rounded-full border border-border object-cover"
            />
            <div class="min-w-0 flex-1">
              <p
                class="truncate font-semibold text-text"
                x-text="video.author?.nickname || 'Неизвестный автор'"
              ></p>
              <p
                class="truncate text-sm text-muted"
                x-text="video.author?.unique_id ? '@' + video.author.unique_id : ''"
              ></p>
            </div>
            <svg
              class="h-5 w-5 shrink-0"
              :style="{ color: platform?.colors?.icon }"
              viewBox="0 0 24 24"
              fill="currentColor"
            >
              <path :d="platform?.icon" />
            </svg>
            <svg
              class="h-4 w-4 shrink-0 text-muted"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="m8.25 4.5 7.5 7.5-7.5 7.5"
              />
            </svg>
          </button>

          <template x-if="video.title">
            <div class="rounded-2xl border border-border bg-surface p-4">
              <div class="mb-2 flex items-center gap-2">
                <svg
                  class="h-4 w-4 text-muted"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="1.5"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    d="M4.5 6.75h15M4.5 12h15M4.5 17.25h9"
                  />
                </svg>
                <span
                  class="text-xs font-semibold uppercase tracking-wide text-muted"
                  >Описание</span
                >
              </div>
              <p
                class="text-sm leading-relaxed text-text"
                x-text="video.title"
              ></p>
            </div>
          </template>

          <template x-if="visibleStats.length > 0">
            <div
              class="grid gap-2 rounded-2xl border border-border bg-surface p-3"
              :style="{ gridTemplateColumns: 'repeat(' + visibleStats.length + ', minmax(0, 1fr))' }"
            >
              <template x-for="stat in visibleStats" :key="stat.key">
                <div class="py-2 text-center">
                  <div
                    class="mx-auto grid h-9 w-9 place-items-center rounded-full"
                    :style="{ backgroundColor: platform?.colors?.statsBg }"
                  >
                    <svg
                      class="h-4 w-4"
                      :style="{ color: platform?.colors?.statsIcon }"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="1.5"
                      viewBox="0 0 24 24"
                    >
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        :d="stat.icon"
                      />
                    </svg>
                  </div>
                  <p
                    class="mt-1 text-sm font-semibold text-text"
                    x-text="NumberFormatter.formatCompact(video[stat.key])"
                  ></p>
                  <p
                    class="mt-0.5 text-[10px] text-muted"
                    x-text="stat.label"
                  ></p>
                </div>
              </template>
            </div>
          </template>

          <div class="grid grid-cols-2 gap-3 pt-2">
            <button
              @click="saveVideo"
              :disabled="!currentVideoUrl || isSaving"
              :style="{ backgroundColor: platform?.colors?.save }"
              class="flex h-14 items-center justify-center gap-2 rounded-2xl font-semibold text-white transition-all duration-75 ease-out active:scale-[0.97] active:opacity-80 disabled:cursor-not-allowed disabled:opacity-40"
            >
              <svg
                class="h-5 w-5"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"
                />
              </svg>
              <span>Сохранить</span>
            </button>
            <button
              @click="shareStory"
              :disabled="!currentVideoUrl"
              :style="{ backgroundColor: platform?.colors?.story }"
              class="flex h-14 items-center justify-center gap-2 rounded-2xl font-semibold text-black transition-all duration-75 ease-out active:scale-[0.97] active:opacity-80 disabled:cursor-not-allowed disabled:opacity-40"
            >
              <svg
                class="h-5 w-5"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M12 9v6m3-3H9m12 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                />
              </svg>
              <span>В историю</span>
            </button>
          </div>

          <button
            @click="shareLink"
            :disabled="!video || !platform"
            class="flex h-14 w-full items-center justify-center gap-2.5 rounded-2xl border border-border bg-surface font-semibold text-text transition-all duration-75 ease-out active:scale-[0.97] active:opacity-80 disabled:cursor-not-allowed disabled:opacity-40"
          >
            <svg
              class="h-5 w-5 text-muted"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M7.217 10.907a2.25 2.25 0 1 0 0 2.186m0-2.186c.18.324.283.696.283 1.093s-.103.77-.283 1.093m0-2.186 9.566-5.314m-9.566 7.5 9.566 5.314m0 0a2.25 2.25 0 1 0 3.935 2.186 2.25 2.25 0 0 0-3.935-2.186Zm0-12.814a2.25 2.25 0 1 0 3.933-2.185 2.25 2.25 0 0 0-3.933 2.185Z"
              />
            </svg>
            <span>Поделиться ссылкой</span>
          </button>
        </section>
      </template>

      <template x-if="!isLoading && !video">
        <section
          x-ref="sponsorSection"
          x-show="sponsorsLoading || unsubscribedSponsors.length > 0"
          x-transition:enter="transition-all duration-300 ease-out"
          x-transition:enter-start="max-h-0 overflow-hidden opacity-0"
          x-transition:enter-end="max-h-[500px] opacity-100"
          x-transition:leave="transition-all duration-300 ease-in"
          x-transition:leave-start="max-h-[500px] opacity-100"
          x-transition:leave-end="max-h-0 overflow-hidden opacity-0"
          class="fade mt-8"
          style="animation-delay: 120ms"
        >
          <div class="mb-4 flex items-center gap-2">
            <svg
              class="h-5 w-5 text-muted"
              fill="none"
              stroke="currentColor"
              stroke-width="1.5"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456ZM16.894 20.567 16.5 21.75l-.394-1.183a2.25 2.25 0 0 0-1.423-1.423L13.5 18.75l1.183-.394a2.25 2.25 0 0 0 1.423-1.423l.394-1.183.394 1.183a2.25 2.25 0 0 0 1.423 1.423l1.183.394-1.183.394a2.25 2.25 0 0 0-1.423 1.423Z"
              />
            </svg>
            <h2 class="font-semibold text-text">Подпишитесь на спонсоров</h2>
          </div>

          <p class="mb-4 text-sm text-muted">
            Для загрузки видео подпишитесь на каналы спонсоров
          </p>

          <template x-if="sponsorsLoading">
            <div
              class="grid gap-3"
              :class="{ 'grid-cols-1': sponsorsCount === 1, 'grid-cols-2': sponsorsCount === 2, 'grid-cols-3': sponsorsCount >= 3 }"
            >
              <template x-for="i in sponsorsCount" :key="i">
                <div
                  class="flex flex-col items-center gap-3 rounded-2xl border border-border bg-surface p-4"
                >
                  <div class="skeleton h-14 w-14 rounded-full"></div>
                  <div class="skeleton h-4 w-16 rounded"></div>
                  <div class="skeleton h-3 w-12 rounded"></div>
                </div>
              </template>
            </div>
          </template>

          <template x-if="!sponsorsLoading">
            <div
              class="grid gap-3"
              :class="{ 'grid-cols-1': unsubscribedSponsors.length === 1, 'grid-cols-2': unsubscribedSponsors.length === 2, 'grid-cols-3': unsubscribedSponsors.length >= 3 }"
            >
              <template
                x-for="sponsor in unsubscribedSponsors"
                :key="sponsor.username"
              >
                <button
                  @click="openSponsor(sponsor.username)"
                  class="flex flex-col items-center gap-3 rounded-2xl border border-border bg-surface p-4 text-center transition-all duration-75 ease-out active:scale-[0.97] active:opacity-80"
                >
                  <img
                    :src="sponsor.photo"
                    :alt="sponsor.title"
                    @error="if ($event.target.src !== AppAssets.sponsor) $event.target.src = AppAssets.sponsor"
                    class="h-14 w-14 rounded-full border-2 border-border object-cover"
                  />
                  <div class="w-full min-w-0">
                    <p
                      class="truncate text-sm font-semibold text-text"
                      x-text="sponsor.title"
                    ></p>
                    <p
                      class="truncate text-xs text-muted"
                      x-text="'@' + sponsor.username"
                    ></p>
                  </div>
                </button>
              </template>
            </div>
          </template>

          <button
            @click="refreshSubscriptions"
            :disabled="sponsorsLoading"
            class="mt-4 flex h-12 w-full items-center justify-center gap-2 rounded-2xl border border-border bg-surface font-semibold text-text transition-all duration-75 ease-out active:scale-[0.97] active:opacity-80 disabled:opacity-40"
          >
            <svg
              class="h-5 w-5 text-muted"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99"
              />
            </svg>
            <span>Проверить подписки</span>
          </button>
        </section>
      </template>

      <template x-if="!isLoading && !video">
        <section class="fade mt-8" style="animation-delay: 100ms">
          <div class="mb-4 flex items-center justify-between">
            <div class="flex items-center gap-2">
              <svg
                class="h-5 w-5 text-muted"
                fill="none"
                stroke="currentColor"
                stroke-width="1.5"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
                />
              </svg>
              <h2 class="font-semibold text-text">Недавние видео</h2>
            </div>
            <button
              x-show="history.length > 0"
              @click="clearHistory"
              class="text-sm text-muted transition-all duration-75 ease-out active:scale-[0.97] active:opacity-80"
            >
              Очистить
            </button>
          </div>

          <p class="mb-4 text-sm text-muted">
            Синхронизируются между всеми вашими устройствами
          </p>

          <template x-if="history.length === 0">
            <div
              class="rounded-2xl border border-border bg-surface p-6 text-center"
            >
              <div
                class="mx-auto mb-4 grid h-14 w-14 place-items-center rounded-full bg-border"
              >
                <svg
                  class="h-7 w-7 text-muted"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="1.5"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    d="m15.75 10.5 4.72-4.72a.75.75 0 0 1 1.28.53v11.38a.75.75 0 0 1-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 0 0 2.25-2.25v-9a2.25 2.25 0 0 0-2.25-2.25h-9A2.25 2.25 0 0 0 2.25 7.5v9a2.25 2.25 0 0 0 2.25 2.25Z"
                  />
                </svg>
              </div>
              <p class="font-semibold text-text">История пуста</p>
              <p class="mt-1 text-sm text-muted">
                Сохраните видео, чтобы оно появилось здесь
              </p>
            </div>
          </template>

          <template x-if="history.length > 0">
            <div
              class="-mx-5 flex gap-3 overflow-x-auto px-5 pb-2 [-webkit-overflow-scrolling:touch] [scrollbar-width:none] [&::-webkit-scrollbar]:hidden"
            >
              <template x-for="item in history" :key="item.id">
                <button
                  @click="loadFromHistory(item)"
                  class="w-[88px] shrink-0 transition-all duration-75 ease-out active:scale-[0.97] active:opacity-80"
                >
                  <div
                    class="relative mb-2 h-[120px] w-[88px] overflow-hidden rounded-xl border border-border"
                  >
                    <img
                      :src="item.cover"
                      @error="if ($event.target.src !== AppAssets.cover) $event.target.src = AppAssets.cover"
                      class="h-full w-full object-cover"
                      loading="lazy"
                    />
                    <div
                      class="absolute inset-x-0 bottom-0 h-12 bg-gradient-to-t from-black/60 to-transparent"
                    ></div>
                    <div
                      class="absolute bottom-2 left-2 grid h-5 w-5 place-items-center rounded-full bg-black"
                    >
                      <svg
                        class="h-3 w-3"
                        :style="{ color: PlatformRegistry.get(item.platform)?.colors?.icon }"
                        viewBox="0 0 24 24"
                        fill="currentColor"
                      >
                        <path :d="PlatformRegistry.get(item.platform)?.icon" />
                      </svg>
                    </div>
                    <div
                      x-show="item.quality"
                      class="absolute bottom-2 right-2 flex items-center"
                    >
                      <span
                        class="text-[9px] font-semibold leading-none tracking-wide text-white drop-shadow-sm"
                        x-text="item.quality?.toUpperCase()"
                      ></span>
                    </div>
                  </div>
                  <p
                    class="truncate text-left text-xs text-muted"
                    x-text="item.author"
                  ></p>
                </button>
              </template>
            </div>
          </template>
        </section>
      </template>

      <footer
        class="fade mt-auto pt-12"
        style="animation-delay: 150ms"
        x-show="!isLoading && !video"
      >
        <p class="mb-4 text-center text-sm text-muted">
          Поддерживаемые платформы
        </p>
        <div class="flex flex-wrap justify-center gap-3">
          <template x-for="p in PlatformRegistry.all()" :key="p.name">
            <div
              class="flex items-center gap-2.5 rounded-xl border border-border bg-surface px-5 py-3"
            >
              <svg
                class="h-5 w-5"
                :style="{ color: p.colors?.icon }"
                viewBox="0 0 24 24"
                fill="currentColor"
              >
                <path :d="p.icon" />
              </svg>
              <span
                class="text-sm font-semibold text-text"
                x-text="p.name"
              ></span>
            </div>
          </template>
        </div>

        <template x-if="TelegramWebApp.canAddToHomeScreen">
          <button
            @click="TelegramWebApp.addToHomeScreen()"
            class="mx-auto mt-6 flex items-center gap-1.5 border-0 bg-transparent p-0 text-sm font-medium text-muted transition-opacity duration-75 active:opacity-60 hidden"
          >
            <svg
              class="h-4 w-4 text-muted"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M12 4.5v15m7.5-7.5h-15"
              />
            </svg>
            <span>Добавить на главный экран</span>
          </button>
        </template>
      </footer>
    </main>

    <script type="module">
      import Alpine from "https://cdn.jsdelivr.net/npm/alpinejs@3.15.3/+esm";

      const AppConfig = Object.freeze({
        BOT_USERNAME: "ClipperAppBot",
        API_MODE: "direct",
        SERVER_URL: "",
        BOT_API_URL: "",
        FETCH_TIMEOUT: 15000,
        PROGRESS_INTERVAL: 100,
        PROGRESS_STEP_MIN: 2,
        PROGRESS_STEP_MAX: 10,
        PROGRESS_LIMIT: 100,
        HISTORY_MAX: 20,
        HISTORY_KEY: "clipper_history",
        SPONSORS: [],
      });

      const AppAssets = Object.freeze({
        avatar:
          "data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 48 48%22><rect fill=%22%23e5e5e5%22 width=%2248%22 height=%2248%22/></svg>",
        cover:
          "data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 88 120%22><rect fill=%22%23e5e5e5%22 width=%2288%22 height=%22120%22/></svg>",
        sponsor:
          "data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 48 48%22><defs><linearGradient id=%22g%22 x1=%220%25%22 y1=%220%25%22 x2=%22100%25%22 y2=%22100%25%22><stop offset=%220%25%22 stop-color=%22%23667eea%22/><stop offset=%22100%25%22 stop-color=%22%23764ba2%22/></linearGradient></defs><rect fill=%22url(%23g)%22 width=%2248%22 height=%2248%22/></svg>",
      });

      class NumberFormatter {
        static formatDuration(seconds) {
          if (!seconds || !Number.isFinite(seconds)) return "0:00";
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, "0")}`;
        }

        static formatCompact(num) {
          if (!num || !Number.isFinite(num)) return "0";
          if (num >= 1e6) return `${(num / 1e6).toFixed(1)}M`;
          if (num >= 1e3) return `${(num / 1e3).toFixed(1)}K`;
          return num.toString();
        }
      }

      class UrlValidator {
        static isValid(value) {
          try {
            const url = new URL(value);
            return ["http:", "https:"].includes(url.protocol);
          } catch {
            return false;
          }
        }
      }

      class ErrorHandler {
        static log(context, error) {
          console.error(`[Clipper][${context}]`, error);
        }

        static getMessage(error) {
          if (error?.name === "AbortError") return "Превышено время ожидания";
          if (error?.message) return error.message;
          return "Произошла неизвестная ошибка";
        }
      }

      class HistoryStorage {
        static get cloudStorage() {
          return window.Telegram?.WebApp?.CloudStorage;
        }

        static async getAll() {
          try {
            const storage = this.cloudStorage;
            if (!storage) {
              return (
                JSON.parse(localStorage.getItem(AppConfig.HISTORY_KEY)) || []
              );
            }

            return new Promise((resolve) => {
              storage.getItem(AppConfig.HISTORY_KEY, (err, value) => {
                if (err || !value) {
                  resolve([]);
                  return;
                }
                try {
                  resolve(JSON.parse(value) || []);
                } catch {
                  resolve([]);
                }
              });
            });
          } catch {
            return [];
          }
        }

        static async add(item) {
          try {
            const storage = this.cloudStorage;
            const list = (await this.getAll()).filter((i) => i.id !== item.id);
            list.unshift(item);
            const data = JSON.stringify(list.slice(0, AppConfig.HISTORY_MAX));

            if (!storage) {
              localStorage.setItem(AppConfig.HISTORY_KEY, data);
              return;
            }

            return new Promise((resolve) => {
              storage.setItem(AppConfig.HISTORY_KEY, data, (err) => {
                if (err) ErrorHandler.log("HistoryStorage.add", err);
                resolve();
              });
            });
          } catch (err) {
            ErrorHandler.log("HistoryStorage.add", err);
          }
        }

        static async updateQuality(id, quality) {
          try {
            const storage = this.cloudStorage;
            const list = await this.getAll();
            const item = list.find((i) => i.id === id);

            if (!item) return;

            item.quality = quality;
            const data = JSON.stringify(list);

            if (!storage) {
              localStorage.setItem(AppConfig.HISTORY_KEY, data);
              return;
            }

            return new Promise((resolve) => {
              storage.setItem(AppConfig.HISTORY_KEY, data, (err) => {
                if (err) ErrorHandler.log("HistoryStorage.updateQuality", err);
                resolve();
              });
            });
          } catch (err) {
            ErrorHandler.log("HistoryStorage.updateQuality", err);
          }
        }

        static async clear() {
          try {
            const storage = this.cloudStorage;

            if (!storage) {
              localStorage.removeItem(AppConfig.HISTORY_KEY);
              return;
            }

            return new Promise((resolve) => {
              storage.removeItem(AppConfig.HISTORY_KEY, (err) => {
                if (err) ErrorHandler.log("HistoryStorage.clear", err);
                resolve();
              });
            });
          } catch (err) {
            ErrorHandler.log("HistoryStorage.clear", err);
          }
        }
      }

      class TelegramWebApp {
        static get instance() {
          return window.Telegram?.WebApp;
        }

        static initialize() {
          const app = this.instance;
          if (!app) return;

          try {
            app.ready();
            app.requestFullscreen?.();
            app.disableVerticalSwipes?.();
            app.setHeaderColor?.("#0b0b0f");
            app.setBackgroundColor?.("#0b0b0f");
          } catch (err) {
            ErrorHandler.log("TelegramWebApp.initialize", err);
          }
        }

        static get startParam() {
          try {
            return this.instance?.initDataUnsafe?.start_param || null;
          } catch {
            return null;
          }
        }

        static get userId() {
          try {
            return this.instance?.initDataUnsafe?.user?.id || null;
          } catch {
            return null;
          }
        }

        static get initData() {
          try {
            return this.instance?.initData || "";
          } catch {
            return "";
          }
        }

        static hapticImpact(style = "light") {
          try {
            this.instance?.HapticFeedback?.impactOccurred(style);
          } catch (err) {
            ErrorHandler.log("TelegramWebApp.hapticImpact", err);
          }
        }

        static hapticNotification(type) {
          try {
            this.instance?.HapticFeedback?.notificationOccurred(type);
          } catch (err) {
            ErrorHandler.log("TelegramWebApp.hapticNotification", err);
          }
        }

        static downloadFile(url, filename) {
          try {
            if (!this.instance?.downloadFile) return false;
            this.instance.downloadFile({ url, file_name: filename });
            return true;
          } catch (err) {
            ErrorHandler.log("TelegramWebApp.downloadFile", err);
            return false;
          }
        }

        static shareToStory(mediaUrl, text) {
          try {
            if (!this.instance?.shareToStory) return false;
            this.instance.shareToStory(mediaUrl, {
              text: text || "",
              widget_link: {
                url: `https://t.me/${AppConfig.BOT_USERNAME}`,
                name: "Clipper",
              },
            });
            return true;
          } catch (err) {
            ErrorHandler.log("TelegramWebApp.shareToStory", err);
            return false;
          }
        }

        static openExternalLink(url) {
          try {
            if (this.instance?.openLink) {
              this.instance.openLink(url);
            } else {
              globalThis.open(url, "_blank", "noopener,noreferrer");
            }
          } catch (err) {
            ErrorHandler.log("TelegramWebApp.openExternalLink", err);
          }
        }

        static openTelegramLink(url) {
          try {
            if (this.instance?.openTelegramLink) {
              this.instance.openTelegramLink(url);
            } else {
              globalThis.open(url, "_blank", "noopener,noreferrer");
            }
          } catch (err) {
            ErrorHandler.log("TelegramWebApp.openTelegramLink", err);
          }
        }

        static shareUrl(url, text) {
          try {
            const shareLink = `https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text || "")}`;
            this.openTelegramLink(shareLink);
            return true;
          } catch (err) {
            ErrorHandler.log("TelegramWebApp.shareUrl", err);
            return false;
          }
        }

        static showConfirm(message, callback) {
          try {
            if (this.instance?.showConfirm) {
              this.instance.showConfirm(message, callback);
              return true;
            }
            const result = confirm(message);
            callback(result);
            return true;
          } catch (err) {
            ErrorHandler.log("TelegramWebApp.showConfirm", err);
            const result = confirm(message);
            callback(result);
            return false;
          }
        }

        static requestWriteAccess() {
          try {
            if (this.instance?.requestWriteAccess) {
              this.instance.requestWriteAccess();
              return true;
            }
            return false;
          } catch (err) {
            ErrorHandler.log("TelegramWebApp.requestWriteAccess", err);
            return false;
          }
        }

        static addToHomeScreen() {
          try {
            if (this.instance?.addToHomeScreen) {
              this.instance.addToHomeScreen();
              return true;
            }
            return false;
          } catch (err) {
            ErrorHandler.log("TelegramWebApp.addToHomeScreen", err);
            return false;
          }
        }

        static get canAddToHomeScreen() {
          try {
            return typeof this.instance?.addToHomeScreen === "function";
          } catch {
            return false;
          }
        }

        static get canRequestWriteAccess() {
          try {
            return typeof this.instance?.requestWriteAccess === "function";
          } catch {
            return false;
          }
        }
      }

      class ApiClient {
        static async request(endpoint, data = {}) {
          const url = this.buildUrl(endpoint);
          const options = this.buildOptions(data);

          const controller = new AbortController();
          const timeoutId = setTimeout(
            () => controller.abort(),
            AppConfig.FETCH_TIMEOUT,
          );

          try {
            const response = await fetch(url, {
              ...options,
              signal: controller.signal,
            });

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            return await response.json();
          } catch (err) {
            ErrorHandler.log("ApiClient.request", err);
            throw err;
          } finally {
            clearTimeout(timeoutId);
          }
        }

        static buildUrl(endpoint) {
          if (AppConfig.API_MODE === "server") {
            return `${AppConfig.SERVER_URL}/${endpoint}`;
          }
          return `${AppConfig.BOT_API_URL}/${endpoint}`;
        }

        static buildOptions(data) {
          const options = {
            method: "POST",
            headers: { "Content-Type": "application/json" },
          };

          if (AppConfig.API_MODE === "server") {
            options.body = JSON.stringify({
              ...data,
              initData: TelegramWebApp.initData,
            });
          } else {
            options.body = JSON.stringify(data);
          }

          return options;
        }
      }

      class SponsorApiService {
        static channelCache = new Map();
        static subscriptionCache = new Map();
        static CACHE_TTL = 5 * 60 * 1000;
        static cacheTimestamps = new Map();

        static getCachedChannel(username) {
          const cached = this.channelCache.get(username);
          const timestamp = this.cacheTimestamps.get(`channel_${username}`);
          if (cached && timestamp && Date.now() - timestamp < this.CACHE_TTL) {
            return cached;
          }
          this.channelCache.delete(username);
          this.cacheTimestamps.delete(`channel_${username}`);
          return null;
        }

        static setCachedChannel(username, data) {
          this.channelCache.set(username, data);
          this.cacheTimestamps.set(`channel_${username}`, Date.now());
        }

        static getCachedSubscription(cacheKey) {
          const cached = this.subscriptionCache.get(cacheKey);
          const timestamp = this.cacheTimestamps.get(`sub_${cacheKey}`);
          if (
            cached !== undefined &&
            timestamp &&
            Date.now() - timestamp < this.CACHE_TTL
          ) {
            return cached;
          }
          this.subscriptionCache.delete(cacheKey);
          this.cacheTimestamps.delete(`sub_${cacheKey}`);
          return undefined;
        }

        static setCachedSubscription(cacheKey, value) {
          this.subscriptionCache.set(cacheKey, value);
          this.cacheTimestamps.set(`sub_${cacheKey}`, Date.now());
        }

        static getSponsors() {
          return AppConfig.SPONSORS.slice(0, 3);
        }

        static async fetchChannelInfo(username) {
          const cleanUsername = username.replace(/^@/, "").trim();
          const cached = this.getCachedChannel(cleanUsername);
          if (cached) return cached;

          try {
            if (AppConfig.API_MODE === "server") {
              return await this.fetchChannelFromServer(cleanUsername);
            }
            return await this.fetchChannelDirect(cleanUsername);
          } catch (err) {
            ErrorHandler.log("SponsorApiService.fetchChannelInfo", err);
            return this.createFallbackChannel(cleanUsername);
          }
        }

        static async fetchChannelFromServer(username) {
          const result = await ApiClient.request("sponsors/channel", {
            username,
          });
          if (!result.ok) throw new Error("Channel not found");

          const channelData = {
            username,
            title: result.data.title || username,
            photo: result.data.photo || AppAssets.sponsor,
          };

          this.setCachedChannel(username, channelData);
          return channelData;
        }

        static async fetchChannelDirect(username) {
          const chat = await ApiClient.request("getChat", {
            chat_id: `@${username}`,
          });
          if (!chat.ok || !chat.result) throw new Error("Channel not found");

          let photoUrl = AppAssets.sponsor;

          if (chat.result.photo?.big_file_id) {
            const file = await ApiClient.request("getFile", {
              file_id: chat.result.photo.big_file_id,
            });

            if (file.ok && file.result?.file_path) {
              const botToken = AppConfig.BOT_API_URL.split("/bot")[1];
              photoUrl = `https://api.telegram.org/file/bot${botToken}/${file.result.file_path}`;
            }
          }

          const channelData = {
            username,
            title: chat.result.title || username,
            photo: photoUrl,
          };

          this.setCachedChannel(username, channelData);
          return channelData;
        }

        static createFallbackChannel(username) {
          return {
            username,
            title: username,
            photo: AppAssets.sponsor,
          };
        }

        static async checkSubscription(username) {
          const userId = TelegramWebApp.userId;
          if (!userId) return false;

          const cleanUsername = username.replace(/^@/, "").trim();
          const cacheKey = `${userId}_${cleanUsername}`;
          const cached = this.getCachedSubscription(cacheKey);
          if (cached !== undefined) return cached;

          try {
            if (AppConfig.API_MODE === "server") {
              return await this.checkSubscriptionFromServer(
                cleanUsername,
                cacheKey,
              );
            }
            return await this.checkSubscriptionDirect(
              cleanUsername,
              userId,
              cacheKey,
            );
          } catch (err) {
            ErrorHandler.log("SponsorApiService.checkSubscription", err);
            this.setCachedSubscription(cacheKey, false);
            return false;
          }
        }

        static async checkSubscriptionFromServer(username, cacheKey) {
          const result = await ApiClient.request("sponsors/check", {
            username,
          });
          const isSubscribed = result.ok && result.subscribed === true;
          this.setCachedSubscription(cacheKey, isSubscribed);
          return isSubscribed;
        }

        static async checkSubscriptionDirect(username, userId, cacheKey) {
          const member = await ApiClient.request("getChatMember", {
            chat_id: `@${username}`,
            user_id: userId,
          });

          if (!member.ok || !member.result) {
            this.setCachedSubscription(cacheKey, false);
            return false;
          }

          const subscribedStatuses = ["creator", "administrator", "member"];
          const isSubscribed = subscribedStatuses.includes(
            member.result.status,
          );
          this.setCachedSubscription(cacheKey, isSubscribed);
          return isSubscribed;
        }

        static async fetchAllSponsorsWithStatus() {
          const sponsors = this.getSponsors();
          if (sponsors.length === 0) return [];

          try {
            if (AppConfig.API_MODE === "server") {
              const result = await ApiClient.request("sponsors/list");

              if (result.ok && Array.isArray(result.data)) {
                const userId = TelegramWebApp.userId;
                result.data.forEach((sponsor) => {
                  this.setCachedChannel(sponsor.username, {
                    username: sponsor.username,
                    title: sponsor.title,
                    photo: sponsor.photo,
                  });

                  if (userId) {
                    this.setCachedSubscription(
                      `${userId}_${sponsor.username}`,
                      sponsor.subscribed,
                    );
                  }
                });

                return result.data;
              }
            }

            return await Promise.all(
              sponsors.map(async (username) => {
                const channel = await this.fetchChannelInfo(username);
                const subscribed = await this.checkSubscription(username);
                return { ...channel, subscribed };
              }),
            );
          } catch (err) {
            ErrorHandler.log(
              "SponsorApiService.fetchAllSponsorsWithStatus",
              err,
            );
            return [];
          }
        }

        static clearSubscriptionCache() {
          this.subscriptionCache.clear();
          for (const key of this.cacheTimestamps.keys()) {
            if (key.startsWith("sub_")) {
              this.cacheTimestamps.delete(key);
            }
          }
        }

        static getChannelUrl(username) {
          return `https://t.me/${username.replace(/^@/, "").trim()}`;
        }
      }

      class VideoPlatform {
        constructor(config) {
          this.name = config.name;
          this.colors = config.colors;
          this.icon = config.icon;
          this.patterns = config.patterns;
          this.stats = config.stats;
          this.authorUrlTemplate = config.authorUrlTemplate;
          this.supportsQuality = config.supportsQuality || false;
          this.qualities = config.qualities || [];
          this._fetch = config._fetch;
          this._extractId = config._extractId;
          this._buildUrlFromId = config._buildUrlFromId;
        }

        match(url) {
          return this.patterns.some((pattern) => pattern.test(url));
        }

        extractId(url) {
          try {
            if (this._extractId) return this._extractId(url);
            for (const pattern of this.patterns) {
              const match = url.match(pattern);
              if (match?.[1]) return match[1];
            }
            return null;
          } catch {
            return null;
          }
        }

        getAuthorUrl(author) {
          try {
            if (!this.authorUrlTemplate || !author?.unique_id) return null;
            return this.authorUrlTemplate.replace(
              "{username}",
              author.unique_id,
            );
          } catch {
            return null;
          }
        }

        async fetchVideo(url, quality = "hd") {
          const controller = new AbortController();
          const timeoutId = setTimeout(
            () => controller.abort(),
            AppConfig.FETCH_TIMEOUT,
          );

          try {
            const q = this.supportsQuality ? quality : "sd";
            const data = await this._fetch(url, controller.signal, q);
            if (!data?.play) throw new Error("Видео недоступно");
            return data;
          } finally {
            clearTimeout(timeoutId);
          }
        }

        getFilename(video, quality) {
          const id = video?.id || Date.now();
          const qualitySuffix = quality ? `_${quality}` : "";
          return `${this.name.toLowerCase()}_${id}${qualitySuffix}.mp4`;
        }

        getShareParam(video, url) {
          try {
            const id = video?.id || this.extractId(url);
            if (id) return `${this.name.toLowerCase()}_${id}`;
            const utf8Bytes = new TextEncoder().encode(url);
            const binaryString = String.fromCharCode(...utf8Bytes);
            return btoa(binaryString).replace(
              /[+/=]/g,
              (c) => ({ "+": "-", "/": "_" })[c] || "",
            );
          } catch {
            return null;
          }
        }

        buildUrlFromId(id) {
          try {
            return this._buildUrlFromId?.(id) || null;
          } catch {
            return null;
          }
        }
      }

      class PlatformRegistry {
        static platforms = [];

        static register(config) {
          this.platforms.push(new VideoPlatform(config));
        }

        static detect(url) {
          if (!url) return null;
          return this.platforms.find((p) => p.match(url)) || null;
        }

        static get(name) {
          if (!name) return null;
          return this.platforms.find((p) => p.name === name) || null;
        }

        static all() {
          return this.platforms;
        }

        static parseStartParam(param) {
          if (!param || typeof param !== "string") return null;

          try {
            const platformMatch = param.match(/^([a-z]+)_(.+)$/i);

            if (platformMatch) {
              const [, platformName, id] = platformMatch;

              const platform = this.platforms.find(
                (p) => p.name.toLowerCase() === platformName.toLowerCase(),
              );

              if (!platform) {
                return { error: "unsupported_platform", platformName };
              }

              if (/^\d+$/.test(id)) {
                const url = platform.buildUrlFromId(id);
                if (url) {
                  return { platform: platform.name, id, url };
                }
              }

              return { error: "invalid_id", platformName: platform.name };
            }

            if (param.length > 10) {
              let base64 = param.replace(/-/g, "+").replace(/_/g, "/");
              const padLength = (4 - (base64.length % 4)) % 4;
              base64 += "=".repeat(padLength);

              try {
                const binaryString = atob(base64);
                const bytes = Uint8Array.from(binaryString, (c) =>
                  c.charCodeAt(0),
                );
                const decoded = new TextDecoder("utf-8", {
                  fatal: true,
                }).decode(bytes);

                if (
                  decoded.startsWith("http") &&
                  UrlValidator.isValid(decoded)
                ) {
                  const platform = this.detect(decoded);
                  if (platform) {
                    return { platform: platform.name, id: null, url: decoded };
                  }
                  return { error: "unsupported_platform", url: decoded };
                }
              } catch {}
            }
          } catch (err) {
            ErrorHandler.log("PlatformRegistry.parseStartParam", err);
          }

          return { error: "invalid_format" };
        }
      }

      class TikTokErrorHandler {
        static ERROR_MAP = {
          "url parsing failed":
            "Не удалось обработать ссылку. Проверьте правильность URL",
          "video not found": "Видео не найдено",
          "video is private": "Это приватное видео",
          "video has been removed": "Видео было удалено",
          "video is unavailable": "Видео недоступно",
          "user not found": "Пользователь не найден",
          "account is private": "Аккаунт приватный",
          "video under review": "Видео на проверке",
          "content not available": "Контент недоступен в вашем регионе",
          "rate limit exceeded": "Слишком много запросов. Попробуйте позже",
          "invalid url": "Неверный формат ссылки",
          "empty url": "Ссылка не указана",
        };

        static translate(message) {
          if (!message) return "Произошла неизвестная ошибка";

          const lowerMessage = message.toLowerCase().trim();

          for (const [key, value] of Object.entries(this.ERROR_MAP)) {
            if (lowerMessage.includes(key.toLowerCase())) {
              return value;
            }
          }

          if (lowerMessage.includes("private")) {
            return "Это приватное видео";
          }
          if (
            lowerMessage.includes("not found") ||
            lowerMessage.includes("not exist")
          ) {
            return "Видео не найдено";
          }
          if (
            lowerMessage.includes("removed") ||
            lowerMessage.includes("deleted")
          ) {
            return "Видео было удалено";
          }
          if (lowerMessage.includes("unavailable")) {
            return "Видео недоступно";
          }
          if (
            lowerMessage.includes("parsing") ||
            lowerMessage.includes("parse")
          ) {
            return "Не удалось обработать ссылку. Убедитесь, что это корректная ссылка TikTok";
          }
          if (
            lowerMessage.includes("region") ||
            lowerMessage.includes("country")
          ) {
            return "Видео недоступно в вашем регионе";
          }
          if (
            lowerMessage.includes("limit") ||
            lowerMessage.includes("too many")
          ) {
            return "Слишком много запросов. Подождите минуту и попробуйте снова";
          }

          return "Не удалось загрузить видео. Попробуйте другую ссылку";
        }
      }

      PlatformRegistry.register({
        name: "TikTok",
        colors: {
          primary: "#fe2c55",
          progress: "#ffffff",
          icon: "#ffffff",
          save: "#fe2c55",
          story: "#ffffff",
          statsBg: "#fe2c5520",
          statsIcon: "#fe2c55",
        },
        icon: "M19.59 6.69a4.83 4.83 0 0 1-3.77-4.25V2h-3.45v13.67a2.89 2.89 0 0 1-5.2 1.74 2.89 2.89 0 0 1 2.31-4.64c.29 0 .58.04.88.13V9.4c-.29-.03-.6-.05-1-.05A6.33 6.33 0 0 0 5 20.1a6.34 6.34 0 0 0 10.86-4.43v-7a8.16 8.16 0 0 0 4.77 1.52v-3.4c-.35-.05-.7-.08-1.04-.1z",
        patterns: [
          /^https?:\/\/(?:www\.)?tiktok\.com\/@[\w.-]+\/video\/(\d+)/i,
          /^https?:\/\/(?:www\.)?tiktok\.com\/t\/([\w-]+)/i,
          /^https?:\/\/vm\.tiktok\.com\/([\w-]+)/i,
          /^https?:\/\/vt\.tiktok\.com\/([\w-]+)/i,
        ],
        authorUrlTemplate: "https://www.tiktok.com/@{username}",
        supportsQuality: true,
        qualities: [
          { key: "hd", label: "HD", param: 1 },
          { key: "sd", label: "SD", param: 0 },
        ],
        stats: [
          {
            key: "play_count",
            label: "Просмотры",
            icon: "M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.347a1.125 1.125 0 0 1 0 1.972l-11.54 6.347a1.125 1.125 0 0 1-1.667-.986V5.653Z",
          },
          {
            key: "digg_count",
            label: "Лайки",
            icon: "M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12Z",
          },
          {
            key: "comment_count",
            label: "Комменты",
            icon: "M12 20.25c4.97 0 9-3.694 9-8.25s-4.03-8.25-9-8.25S3 7.444 3 12c0 2.104.859 4.023 2.273 5.48.432.447.74 1.04.586 1.641a4.483 4.483 0 0 1-.923 1.785A5.969 5.969 0 0 0 6 21c1.282 0 2.47-.402 3.445-1.087.81.22 1.668.337 2.555.337Z",
          },
          {
            key: "share_count",
            label: "Репосты",
            icon: "M7.217 10.907a2.25 2.25 0 1 0 0 2.186m0-2.186c.18.324.283.696.283 1.093s-.103.77-.283 1.093m0-2.186 9.566-5.314m-9.566 7.5 9.566 5.314m0 0a2.25 2.25 0 1 0 3.935 2.186 2.25 2.25 0 0 0-3.935-2.186Zm0-12.814a2.25 2.25 0 1 0 3.933-2.185 2.25 2.25 0 0 0-3.933 2.185Z",
          },
        ],
        _extractId(url) {
          const match = url.match(/video\/(\d+)/i);
          return match?.[1] || null;
        },
        _buildUrlFromId(id) {
          return `https://www.tiktok.com/@_/video/${id}`;
        },
        async _fetch(url, signal, quality = "hd") {
          if (!url || typeof url !== "string") {
            throw new Error("Вставьте ссылку на видео");
          }

          const trimmedUrl = url.trim();
          if (!trimmedUrl) {
            throw new Error("Ссылка не может быть пустой");
          }

          let response;
          try {
            response = await fetch("https://www.tikwm.com/api/", {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
              },
              body: new URLSearchParams({ url: trimmedUrl, hd: 1 }),
              signal,
            });
          } catch (err) {
            if (err.name === "AbortError") throw err;
            throw new Error("Ошибка сети. Проверьте подключение к интернету");
          }

          if (!response.ok) {
            throw new Error(`Сервер недоступен (${response.status})`);
          }

          let json;
          try {
            json = await response.json();
          } catch {
            throw new Error("Ошибка обработки ответа сервера");
          }

          if (json.code !== 0) {
            throw new Error(TikTokErrorHandler.translate(json.msg));
          }

          const data = json.data;

          if (!data) {
            throw new Error("Сервер вернул пустой ответ");
          }

          if (!data.play) {
            throw new Error(
              "Ссылка на видео недоступна. Возможно, видео приватное или удалено",
            );
          }

          data.hdPlay = data.hdplay || null;
          data.hasHD = Boolean(data.hdplay);
          data.currentQuality = quality === "hd" && data.hasHD ? "hd" : "sd";

          return data;
        },
      });

      globalThis.NumberFormatter = NumberFormatter;
      globalThis.PlatformRegistry = PlatformRegistry;
      globalThis.TelegramWebApp = TelegramWebApp;
      globalThis.AppAssets = AppAssets;

      Alpine.data("ClipperApp", () => ({
        url: "",
        platform: null,
        isLoading: false,
        progress: 0,
        video: null,
        error: null,
        history: [],
        sponsorsList: [],
        sponsorsLoading: true,
        progressTimer: null,
        selectedQuality: "hd",
        featurePromptTimer: null,
        isRefreshing: false,
        downloadAbortController: null,
        isChangingQuality: false,
        isSaving: false,

        get statusText() {
          if (this.isLoading) return "Загрузка видео...";
          if (this.error) return "Попробуйте другую ссылку";
          if (this.video) return "Видео готово к сохранению";
          if (this.platform) return this.platform.name;
          return "Сохраняйте видео легко и быстро";
        },

        get loadingText() {
          if (this.progress < 30) return "Подключение к серверу...";
          if (this.progress < 60) return "Получение видео...";
          if (this.progress < 90) return "Обработка данных...";
          return "Почти готово...";
        },

        get visibleStats() {
          if (!this.platform?.stats || !this.video) return [];
          return this.platform.stats.filter(
            (s) => this.video[s.key] != null && this.video[s.key] > 0,
          );
        },

        get unsubscribedSponsors() {
          return this.sponsorsList.filter((s) => !s.subscribed);
        },

        get hasUnsubscribedSponsors() {
          return this.unsubscribedSponsors.length > 0;
        },

        get sponsorsCount() {
          return AppConfig.SPONSORS.length;
        },

        get hasMultipleQualities() {
          if (!this.platform?.supportsQuality) return false;
          if (!this.video?.hasHD) return false;
          return this.video.hdPlay && this.video.hdPlay !== this.video.play;
        },

        get availableQualities() {
          if (!this.platform?.qualities) return [];
          if (!this.video) return this.platform.qualities;
          if (this.video.hasHD !== true) {
            return this.platform.qualities.filter((q) => q.key === "sd");
          }
          return this.platform.qualities;
        },

        get currentQualityLabel() {
          if (!this.video) return "";
          return this.selectedQuality === "hd" && this.video.hasHD
            ? "HD"
            : "SD";
        },

        get currentVideoUrl() {
          if (!this.video?.play) return null;

          if (this.selectedQuality === "hd" && this.video.hdPlay) {
            if (this.video.hdPlay !== this.video.play) {
              return this.video.hdPlay;
            }
          }
          return this.video.play;
        },

        async init() {
          TelegramWebApp.initialize();
          this.history = await HistoryStorage.getAll();
          this.handleStartParam();
          this.loadSponsors();
          this.promptTelegramFeatures();
        },

        destroy() {
          try {
            this.stopProgress();

            if (this.featurePromptTimer) {
              clearTimeout(this.featurePromptTimer);
              this.featurePromptTimer = null;
            }

            if (this.downloadAbortController) {
              this.downloadAbortController.abort();
              this.downloadAbortController = null;
            }

            this.isLoading = false;
            this.isRefreshing = false;
            this.sponsorsLoading = false;
          } catch (err) {
            ErrorHandler.log("destroy", err);
          }
        },

        promptTelegramFeatures() {
          this.featurePromptTimer = setTimeout(() => {
            if (TelegramWebApp.canRequestWriteAccess) {
              TelegramWebApp.requestWriteAccess();
            }
            this.featurePromptTimer = null;
          }, 2000);
        },

        async loadSponsors() {
          const sponsors = SponsorApiService.getSponsors();
          if (sponsors.length === 0) {
            this.sponsorsLoading = false;
            return;
          }

          try {
            this.sponsorsList =
              await SponsorApiService.fetchAllSponsorsWithStatus();
          } catch (err) {
            ErrorHandler.log("loadSponsors", err);
            this.sponsorsList = [];
          } finally {
            this.sponsorsLoading = false;
          }
        },

        async refreshSubscriptions() {
          if (this.isRefreshing || this.sponsorsLoading) return;

          this.isRefreshing = true;
          this.sponsorsLoading = true;
          SponsorApiService.clearSubscriptionCache();
          TelegramWebApp.hapticImpact("light");

          try {
            const sponsors = SponsorApiService.getSponsors();
            if (sponsors.length === 0) {
              this.sponsorsList = [];
              return;
            }
            this.sponsorsList =
              await SponsorApiService.fetchAllSponsorsWithStatus();
          } catch (err) {
            ErrorHandler.log("refreshSubscriptions", err);
          } finally {
            this.sponsorsLoading = false;
            this.isRefreshing = false;
          }
        },

        openSponsor(username) {
          TelegramWebApp.hapticImpact("light");
          TelegramWebApp.openTelegramLink(
            SponsorApiService.getChannelUrl(username),
          );
        },

        handleStartParam() {
          const param = TelegramWebApp.startParam;
          if (!param) return;

          const parsed = PlatformRegistry.parseStartParam(param);

          if (!parsed || parsed.error) {
            switch (parsed?.error) {
              case "unsupported_platform":
                this.setError(
                  `Платформа "${parsed.platformName || "неизвестная"}" не поддерживается`,
                );
                break;
              case "invalid_id":
                this.setError("Неверный идентификатор видео");
                break;
              case "invalid_format":
              default:
                this.setError("Неверная ссылка");
                break;
            }
            return;
          }

          const platform = PlatformRegistry.get(parsed.platform);
          if (!platform) {
            this.setError("Платформа не поддерживается");
            return;
          }

          const url = parsed.url || platform.buildUrlFromId(parsed.id);
          if (url) {
            this.url = url;
            this.platform = platform;
            this.$nextTick(() => this.download());
          } else {
            this.setError("Не удалось восстановить ссылку");
          }
        },

        detect() {
          this.error = null;

          if (!this.url?.trim()) {
            this.platform = null;
            this.video = null;
            this.selectedQuality = "hd";
            return;
          }

          if (!UrlValidator.isValid(this.url)) {
            this.platform = null;
            this.video = null;
            this.selectedQuality = "hd";
            return;
          }

          const detected = PlatformRegistry.detect(this.url);
          if (detected) {
            if (this.platform?.name !== detected.name) {
              this.selectedQuality = "hd";
            }
            this.platform = detected;
            TelegramWebApp.hapticImpact("light");
          } else {
            this.platform = null;
            this.video = null;
            this.selectedQuality = "hd";
          }
        },

        clear() {
          this.url = "";
          this.platform = null;
          this.video = null;
          this.error = null;
          this.selectedQuality = "hd";
          TelegramWebApp.hapticImpact("light");
        },

        setError(message) {
          this.error = message;
          TelegramWebApp.hapticNotification("error");
        },

        scrollToError() {
          this.$nextTick(() => {
            const errorEl = document.querySelector('[x-ref="errorSection"]');
            if (errorEl) {
              errorEl.scrollIntoView({ behavior: "smooth", block: "center" });
            }
          });
        },

        scrollToSponsors() {
          this.$nextTick(() => {
            const sponsorEl = document.querySelector(
              '[x-ref="sponsorSection"]',
            );
            if (sponsorEl) {
              sponsorEl.scrollIntoView({
                behavior: "smooth",
                block: "center",
              });
            }
          });
        },

        startProgress() {
          this.stopProgress();
          this.progressTimer = setInterval(() => {
            const step =
              Math.floor(
                Math.random() *
                  (AppConfig.PROGRESS_STEP_MAX -
                    AppConfig.PROGRESS_STEP_MIN +
                    1),
              ) + AppConfig.PROGRESS_STEP_MIN;
            this.progress = Math.min(
              this.progress + step,
              AppConfig.PROGRESS_LIMIT,
            );
          }, AppConfig.PROGRESS_INTERVAL);
        },

        stopProgress() {
          if (this.progressTimer) {
            clearInterval(this.progressTimer);
            this.progressTimer = null;
          }
        },

        async selectQuality(quality) {
          if (!this.video || !this.platform) return;
          if (quality === "hd" && !this.video.hasHD) return;
          if (this.selectedQuality === quality) return;
          if (this.isChangingQuality) return;

          this.isChangingQuality = true;

          const videoPlayer = this.$refs.videoPlayer;
          const wasPlaying = videoPlayer && !videoPlayer.paused;
          const currentTime = videoPlayer?.currentTime || 0;

          const oldQuality = this.selectedQuality;

          this.selectedQuality = quality;
          TelegramWebApp.hapticImpact("light");

          await this.$nextTick();

          if (videoPlayer) {
            try {
              videoPlayer.load();

              await new Promise((resolve, reject) => {
                const onLoaded = () => {
                  videoPlayer.removeEventListener("loadeddata", onLoaded);
                  videoPlayer.removeEventListener("error", onError);
                  resolve();
                };
                const onError = () => {
                  videoPlayer.removeEventListener("loadeddata", onLoaded);
                  videoPlayer.removeEventListener("error", onError);
                  reject(new Error("Ошибка загрузки видео"));
                };

                videoPlayer.addEventListener("loadeddata", onLoaded);
                videoPlayer.addEventListener("error", onError);

                setTimeout(resolve, 3000);
              });

              videoPlayer.currentTime = currentTime;

              if (wasPlaying) {
                try {
                  await videoPlayer.play();
                } catch {}
              }
            } catch (err) {
              ErrorHandler.log("selectQuality", err);
              this.selectedQuality = oldQuality;
            }
          }

          await this.updateHistoryQuality();
          this.isChangingQuality = false;
        },

        async updateHistoryQuality() {
          if (!this.video || !this.platform) return;

          const historyId =
            this.video.id || `${this.platform.name}_${Date.now()}`;
          await HistoryStorage.updateQuality(historyId, this.selectedQuality);
          this.history = await HistoryStorage.getAll();
        },

        async saveToHistory() {
          if (!this.video || !this.platform) return;

          await HistoryStorage.add({
            id: this.video.id || `${this.platform.name}_${Date.now()}`,
            cover: this.video.cover,
            author:
              this.video.author?.nickname ||
              this.video.author?.unique_id ||
              "Неизвестный автор",
            url: this.url,
            platform: this.platform.name,
            quality: this.selectedQuality,
          });
          this.history = await HistoryStorage.getAll();
        },

        async download() {
          if (!this.platform || this.isLoading) return;
          if (!this.url?.trim()) return;

          if (this.downloadAbortController) {
            this.downloadAbortController.abort();
          }
          this.downloadAbortController = new AbortController();

          this.isLoading = true;

          while (this.sponsorsLoading) {
            await new Promise((r) => setTimeout(r, 50));
          }

          if (this.hasUnsubscribedSponsors) {
            await this.refreshSubscriptions();
          }

          if (this.hasUnsubscribedSponsors) {
            this.isLoading = false;
            this.downloadAbortController = null;
            this.setError("Подпишитесь на спонсоров для загрузки видео");
            this.scrollToSponsors();
            return;
          }

          this.$refs.input?.blur();
          this.progress = 0;
          this.error = null;
          this.video = null;
          TelegramWebApp.hapticImpact("medium");

          this.startProgress();

          try {
            this.video = await this.platform.fetchVideo(
              this.url,
              this.selectedQuality,
              this.downloadAbortController.signal,
            );
            this.progress = 100;

            if (!this.video.hasHD) {
              this.selectedQuality = "sd";
            } else if (this.video.currentQuality) {
              this.selectedQuality = this.video.currentQuality;
            }

            await this.saveToHistory();
            TelegramWebApp.hapticNotification("success");
          } catch (err) {
            if (err.name !== "AbortError") {
              this.setError(ErrorHandler.getMessage(err));
            }
          } finally {
            this.stopProgress();
            this.isLoading = false;
            this.downloadAbortController = null;
          }
        },

        saveVideo() {
          if (!this.video || !this.platform || this.isSaving) {
            return;
          }

          const videoUrl = this.currentVideoUrl;
          if (!videoUrl) {
            return;
          }

          this.isSaving = true;

          try {
            const filename = this.platform.getFilename(
              this.video,
              this.selectedQuality,
            );
            const success = TelegramWebApp.downloadFile(videoUrl, filename);

            if (success) {
              TelegramWebApp.hapticNotification("success");
            } else {
              this.setError("Скачивание доступно только в мобильном Telegram");
            }
          } finally {
            setTimeout(() => {
              this.isSaving = false;
            }, 500);
          }
        },

        shareStory() {
          if (!this.video || !this.platform) {
            return;
          }

          const videoUrl = this.currentVideoUrl;
          if (!videoUrl) {
            this.setError("Видео недоступно");
            return;
          }

          let text = `Сохранено через @${AppConfig.BOT_USERNAME}`;
          if (this.video.title?.trim()) {
            text = `${this.video.title.trim()}\n\n${text}`;
          }

          const success = TelegramWebApp.shareToStory(videoUrl, text);

          if (success) {
            TelegramWebApp.hapticNotification("success");
          } else {
            this.setError("Истории доступны только в мобильном Telegram");
          }
        },

        shareLink() {
          if (!this.platform || !this.video) {
            this.setError("Нет данных для ссылки");
            return;
          }

          const param = this.platform.getShareParam(this.video, this.url);
          if (!param) {
            this.setError("Не удалось создать ссылку");
            return;
          }

          const shareUrl = `https://t.me/${AppConfig.BOT_USERNAME}/?startapp=${param}`;
          const shareText = `Сохрани видео через @${AppConfig.BOT_USERNAME}`;

          TelegramWebApp.shareUrl(shareUrl, shareText);
          TelegramWebApp.hapticNotification("success");
        },

        openAuthorProfile() {
          TelegramWebApp.hapticImpact("light");
          if (!this.platform || !this.video?.author) return;

          const url = this.platform.getAuthorUrl(this.video.author);
          if (url) {
            TelegramWebApp.openExternalLink(url);
          }
        },

        loadFromHistory(item) {
          if (!item?.url || !item?.platform) {
            this.setError("Некорректные данные");
            return;
          }

          this.url = item.url;
          this.platform = PlatformRegistry.get(item.platform);

          const validQualities = ["hd", "sd"];
          if (
            item.quality &&
            typeof item.quality === "string" &&
            validQualities.includes(item.quality.toLowerCase())
          ) {
            this.selectedQuality = item.quality.toLowerCase();
          } else {
            this.selectedQuality = "hd";
          }

          if (this.platform) {
            TelegramWebApp.hapticImpact("light");
            this.download();
          } else {
            this.setError("Платформа не поддерживается");
          }
        },

        async clearHistory() {
          TelegramWebApp.showConfirm(
            "Вы уверены, что хотите очистить историю?",
            async (confirmed) => {
              if (confirmed) {
                await HistoryStorage.clear();
                this.history = [];
                TelegramWebApp.hapticImpact("medium");
              }
            },
          );
        },
      }));

      Alpine.start();
    </script>
  </body>
</html>
